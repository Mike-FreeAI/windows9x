"use client";

import {
  ProgramEntry,
  programAtomFamily,
  programsAtom,
} from "@/state/programs";
import { registryAtom } from "@/state/registry";
import { windowAtomFamily } from "@/state/window";
import { windowsListAtom } from "@/state/windowsList";
import { getApiText } from "@/lib/apiText";
import { assert } from "@/lib/assert";
import { getRegistryKeys } from "@/lib/getRegistryKeys";
import { useAtomValue, useSetAtom } from "jotai";
import { useEffect, useState } from "react";
import Markdown from "react-markdown";

/**
 * Constructs a prompt for a helper assistant designed for a specific Windows9X program.
 * @param {Object} program - An object representing the Windows9X program.
 * @param {Array} keys - An array of key strings defining the APIs available for the application to use.
 * @returns {string} Returns a string containing a prompt for the user.
 */
const makePrompt = (program: ProgramEntry, keys: string[]) => {
  return `You are a helpful assistant designed for the following Windows9X program:

html\`\`\`
${program.code}
\`\`\`

The Operating System provides a few apis that your application can use. These are defined on window:

${getApiText(keys)}

You can either answer questions about the program or rewrite it to fix the user's issue. If you rewrite the program, you must return the entire new HTML document wrapped in \`\`\`html markers.
`;
};

const betweenHtmlRegex = /```html([\s\S]*)```/;

/**
 * Function component that renders a Help component, equipped with a chat box for assistance in a web application.
 * The helper fetches and updates content, and makes assertions based on the window type and target window. 
 * The Help component also has an input area for new messages and a send button to trigger the sendMessage function.
 * @param {{ id: string }}  id - Unique identifier for the Help component window.
 * @returns {JSX.Element} Returns JSX element - A Help component with message box for communication and assistance.
 */
export function Help({ id }: { id: string }) {
  const helpWindow = useAtomValue(windowAtomFamily(id));
  const windowsListDispatch = useSetAtom(windowsListAtom);
  const registry = useAtomValue(registryAtom);
  assert(
    helpWindow.program.type === "help" && helpWindow.program.targetWindowID,
    "Help window must have a target window ID"
  );
  const targetWindow = useAtomValue(
    windowAtomFamily(helpWindow.program.targetWindowID)
  );
  const programsDispatch = useSetAtom(programsAtom);
  assert(
    targetWindow.program.type === "iframe",
    "Target window is not an iframe"
  );

  const programID = targetWindow.program.programID;

  /**
   * This function is a React useEffect hook that triggers when 'id', 'targetWindow', or 'windowsListDispatch' changes. 
   * It checks if 'targetWindow' is null or undefined, and if so, dispatches a "REMOVE" action to 'windowsListDispatch' with payload 'id'.
   */
  useEffect(() => {
    if (!targetWindow) {
      windowsListDispatch({
        type: "REMOVE",
        payload: id,
      });
    }
  }, [id, targetWindow, windowsListDispatch]);

  const program = useAtomValue(programAtomFamily(programID));

  const keys = getRegistryKeys(registry);

  const [messages, setMessages] = useState<{ role: string; content: string }[]>(
    /**
     * This is an anonymous function that returns an object with 'role' and 'content' properties. The 'content' is generated by the 'makePrompt' method
     * @param {undefined} No parameters are provided in this function.
     * @returns {Array<Object>} Returns an array of a single object with 'role' and 'content' properties
     */
    () => [{ role: "system", content: makePrompt(program!, keys) }]
  );
  const [input, setInput] = useState("");

  /**
   * Asynchronously sends a user message and receives a response, then dispatches an update action if the response contains HTML. Updates messages spontaneously with user and assistant messages.
   * @returns {undefined} This method does not return a value.
   */
  
  const sendMessage = async () => {
    const newMessage = { role: "user", content: input };
    setMessages([...messages, newMessage]);
    setInput("");

    const response = await fetch("/api/chat", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ messages: [...messages, newMessage] }),
    });

    const data = await response.json();

    const newHtml = data.match(betweenHtmlRegex);

    if (newHtml) {
      programsDispatch({
        type: "UPDATE_PROGRAM",
        payload: { id: programID, code: newHtml[1] },
      });
    }

    setMessages([
      ...messages,
      newMessage,
      { role: "assistant", content: data },
    ]);
  };

  return (
    <>
      <div
        className="chat-box"
        style={{
          flex: 1,
          overflowY: "auto",
          padding: "10px",
          border: "1px solid #000",
        }}
      >
        <Message
          msg={{
            role: "system",
            content:
              "Hello! I'm the software engineer who designed this app. \n\n **How can I help you today?**",
          }}
        />
        {messages
          /**
           * Filters out the messages that do not have the role assigned as "system".
           * @param {Array} msg - Array of messages where each object represents a message with properties like role.
           * @returns {Array} Returns a new filtered array consisting of messages not having role as "system".
           */
          .filter((msg) => msg.role !== "system")
          /**
           * Maps over an array of messages and generates a list of Message components.
           * @param {Array} msg - An array of messages.
           * @param {Number} index - The current index in the mapping process.
           * @returns {Object} Returns a list of Message components generated for each message in the array.
           */
          .map((msg, index) => (
            <Message key={index} msg={msg} />
          ))}
      </div>
      <div
        className="chat-input"
        style={{ display: "flex", marginTop: "10px" }}
      >
        <input
          type="text"
          value={input}
          /**
           * Handles the change event on input elements.
           * @param {Object} e - The event object, which contains information about the event, including the value of the input element.
           * @returns {undefined} No return value.
           */
          onChange={(e) => setInput(e.target.value)}
          /**
           * Handle key down events to trigger the sendMessage function when the "Enter" key is pressed.
           * @param {object} e - The event object that contains information about the key press.
           */
          onKeyDown={(e) => e.key === "Enter" && sendMessage()}
          style={{ flex: 1, padding: "5px", border: "1px solid #000" }}
        />
        <button
          onClick={sendMessage}
          style={{ marginLeft: "5px", padding: "5px 10px" }}
        >
          Send
        </button>
      </div>
    </>
  );
}

/**
 * A Functional Component that renders a message in a chat interface. The message can be either from a user or an assistant.
 * The message from the assistant can update the app.
 * Styles are applied based on the role of the message, and its content is parsed as Markdown.
 * 
 * @param {Object} { msg } - An Object with 'role' and 'content' properties. 'role' determines whether the message is from the user or the assistant and 'content' holds the actual text of the message.
 */

const Message = ({ msg }: { msg: { role: string; content: string } }) => (
  <div
    style={{
      margin: "5px 0",
    }}
  >
    <div
      className={`chat-message ${msg.role}`}
      style={{
        display: "inline-block",
        padding: "5px 10px",
        borderRadius: "5px",
        background: msg.role === "user" ? "#acf" : "#eaeaea",
      }}
    >
      <Markdown>
        {msg.role === "assistant"
          ? msg.content.replace(betweenHtmlRegex, "**App updated**")
          : msg.content}
      </Markdown>
    </div>
  </div>
);
